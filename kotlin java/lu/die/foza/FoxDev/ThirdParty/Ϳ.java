//// Decompiled by Jadx - 985ms//package lu.die.foza.FoxDev.ThirdParty;import android.annotation.SuppressLint;import androidx.annotation.RequiresApi;import dalvik.system.VMRuntime;import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandleInfo;import java.lang.invoke.MethodHandles;import java.lang.reflect.Constructor;import java.lang.reflect.Executable;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import kotlin.Unit;import kotlin.jvm.internal.Intrinsics;import kotlin.jvm.internal.SourceDebugExtension;import lu.die.foza.FoxDev.ThirdParty.FozaReflectionEnjoyHelper;import org.jetbrains.annotations.NotNull;import org.jetbrains.annotations.Nullable;import sun.misc.Unsafe;@RequiresApi(api = 26)@SuppressLint({"DiscouragedPrivateApi"})@SourceDebugExtension({"SMAP\nFozaReflectionTaunt.kt\nKotlin\n*S Kotlin\n*F\n+ 1 FozaReflectionTaunt.kt\nlu/die/foza/FoxDev/ThirdParty/FozaReflectionTaunt\n+ 2 fake.kt\nkotlin/jvm/internal/FakeKt\n*L\n1#1,391:1\n1#2:392\n*E\n"})public final class Ϳ {    @NotNull    public static final Ϳ Ϳ = new Ϳ();    @NotNull    public static final Unsafe Ԩ;    public static long ԩ;    public static long Ԫ;    public static long ԫ;    public static long Ԭ;    public static long ԭ;    public static long Ԯ;    public static long ԯ;    public static long ՠ;    public static long ֈ;    public static long ֏;    public static long ׯ;    public static long ؠ;    @Nullable    public static Method ހ;    public static Object ށ;    static {        Object invoke = Unsafe.class.getDeclaredMethod("getUnsafe", new Class[0]).invoke(null, new Object[0]);        Intrinsics.checkNotNull(invoke, "null cannot be cast to non-null type sun.misc.Unsafe");        Unsafe unsafe = (Unsafe) invoke;        ԩ = unsafe.objectFieldOffset(FozaReflectionEnjoyHelper.Executable.class.getDeclaredField("artMethod"));        Ԫ = unsafe.objectFieldOffset(FozaReflectionEnjoyHelper.Executable.class.getDeclaredField("declaringClass"));        ԫ = unsafe.objectFieldOffset(FozaReflectionEnjoyHelper.MethodHandle.class.getDeclaredField("artFieldOrMethod"));        Ԭ = unsafe.objectFieldOffset(FozaReflectionEnjoyHelper.MethodHandleImpl.class.getDeclaredField("info"));        ԭ = unsafe.objectFieldOffset(FozaReflectionEnjoyHelper.Class.class.getDeclaredField("methods"));        Ԯ = unsafe.objectFieldOffset(FozaReflectionEnjoyHelper.Class.class.getDeclaredField("iFields"));        ԯ = unsafe.objectFieldOffset(FozaReflectionEnjoyHelper.Class.class.getDeclaredField("sFields"));        ՠ = unsafe.objectFieldOffset(FozaReflectionEnjoyHelper.HandleInfo.class.getDeclaredField("member"));        Method declaredMethod = FozaReflectionEnjoyHelper.NeverCall.class.getDeclaredMethod("a", new Class[0]);        Method declaredMethod2 = FozaReflectionEnjoyHelper.NeverCall.class.getDeclaredMethod("b", new Class[0]);        declaredMethod.setAccessible(true);        declaredMethod2.setAccessible(true);        MethodHandle unreflect = MethodHandles.lookup().unreflect(declaredMethod);        MethodHandle unreflect2 = MethodHandles.lookup().unreflect(declaredMethod2);        long j = unsafe.getLong(unreflect, ԫ);        long j2 = unsafe.getLong(unreflect2, ԫ);        long j3 = unsafe.getLong(FozaReflectionEnjoyHelper.NeverCall.class, ԭ);        long j4 = j2 - j;        ֈ = j4;        ֏ = (j - j3) - j4;        Field declaredField = FozaReflectionEnjoyHelper.NeverCall.class.getDeclaredField("i");        Field declaredField2 = FozaReflectionEnjoyHelper.NeverCall.class.getDeclaredField("j");        declaredField.setAccessible(true);        declaredField2.setAccessible(true);        MethodHandle unreflectGetter = MethodHandles.lookup().unreflectGetter(declaredField);        MethodHandle unreflectGetter2 = MethodHandles.lookup().unreflectGetter(declaredField2);        long j5 = unsafe.getLong(unreflectGetter, ԫ);        long j6 = unsafe.getLong(unreflectGetter2, ԫ);        long j7 = unsafe.getLong(FozaReflectionEnjoyHelper.NeverCall.class, Ԯ);        ׯ = j6 - j5;        ؠ = j5 - j7;        Ԩ = unsafe;    }    public final boolean Ϳ(@NotNull String... strArr) {        return Ԩ((String[]) Arrays.copyOf(strArr, strArr.length));    }    @NotNull    public final List<Field> Ԩ(@NotNull Class<?> cls) {        ArrayList arrayList = new ArrayList();        if (!cls.isPrimitive() && !cls.isArray()) {            synchronized (this) {                try {                    Field declaredField = FozaReflectionEnjoyHelper.NeverCall.class.getDeclaredField("i");                    declaredField.setAccessible(true);                    MethodHandle unreflectGetter = MethodHandles.lookup().unreflectGetter(declaredField);                    Unsafe unsafe = Ԩ;                    long j = unsafe.getLong(cls, Ԯ);                    if (j != 0) {                        int i = unsafe.getInt(j);                        for (int i2 = 0; i2 < i; i2++) {                            long j2 = ׯ;                            long j3 = ؠ;                            Unsafe unsafe2 = Ԩ;                            unsafe2.putLong(unreflectGetter, ԫ, (i2 * j2) + j + j3);                            unsafe2.putObject(unreflectGetter, Ԭ, (Object) null);                            try {                                MethodHandles.lookup().revealDirect(unreflectGetter);                            } catch (Throwable th) {                            }                            Unsafe unsafe3 = Ԩ;                            Object object = unsafe3.getObject(unreflectGetter, Ԭ);                            Intrinsics.checkNotNull(object, "null cannot be cast to non-null type java.lang.invoke.MethodHandleInfo");                            Object object2 = unsafe3.getObject((MethodHandleInfo) object, ՠ);                            Intrinsics.checkNotNull(object2, "null cannot be cast to non-null type java.lang.reflect.Field");                            arrayList.add((Field) object2);                        }                        Unit unit = Unit.INSTANCE;                    }                } catch (IllegalAccessException e) {                } catch (NoSuchFieldException e2) {                }            }        }        return arrayList;    }    public final boolean Ԩ(String... strArr) {        throw new RuntimeException("Couldn't be decompiled.");    }    @NotNull    public final List<Field> ԩ(@NotNull Class<?> cls) {        ArrayList arrayList = new ArrayList();        if (!cls.isPrimitive() && !cls.isArray()) {            synchronized (this) {                try {                    Field declaredField = FozaReflectionEnjoyHelper.NeverCall.class.getDeclaredField("s");                    declaredField.setAccessible(true);                    MethodHandle unreflectGetter = MethodHandles.lookup().unreflectGetter(declaredField);                    Unsafe unsafe = Ԩ;                    long j = unsafe.getLong(cls, ԯ);                    if (j != 0) {                        int i = unsafe.getInt(j);                        for (int i2 = 0; i2 < i; i2++) {                            long j2 = ׯ;                            long j3 = ؠ;                            Unsafe unsafe2 = Ԩ;                            unsafe2.putLong(unreflectGetter, ԫ, (i2 * j2) + j + j3);                            unsafe2.putObject(unreflectGetter, Ԭ, (Object) null);                            try {                                MethodHandles.lookup().revealDirect(unreflectGetter);                            } catch (Throwable th) {                            }                            Unsafe unsafe3 = Ԩ;                            Object object = unsafe3.getObject(unreflectGetter, Ԭ);                            Intrinsics.checkNotNull(object, "null cannot be cast to non-null type java.lang.invoke.MethodHandleInfo");                            Object object2 = unsafe3.getObject((MethodHandleInfo) object, ՠ);                            Intrinsics.checkNotNull(object2, "null cannot be cast to non-null type java.lang.reflect.Field");                            arrayList.add((Field) object2);                        }                        Unit unit = Unit.INSTANCE;                    }                } catch (IllegalAccessException e) {                } catch (NoSuchFieldException e2) {                }            }        }        return arrayList;    }    public final boolean Ϳ(Class<?>[] clsArr, Object[] objArr) {        if (clsArr.length != objArr.length) {            return false;        }        int length = clsArr.length;        for (int i = 0; i < length; i++) {            if (!clsArr[i].isPrimitive()) {                Object obj = objArr[i];                if (obj != null && !clsArr[i].isInstance(obj)) {                    return false;                }            } else {                if (Intrinsics.areEqual(clsArr[i], Integer.TYPE) && !(objArr[i] instanceof Integer)) {                    return false;                }                if (Intrinsics.areEqual(clsArr[i], Byte.TYPE) && !(objArr[i] instanceof Byte)) {                    return false;                }                if (Intrinsics.areEqual(clsArr[i], Character.TYPE) && !(objArr[i] instanceof Character)) {                    return false;                }                if (Intrinsics.areEqual(clsArr[i], Boolean.TYPE) && !(objArr[i] instanceof Boolean)) {                    return false;                }                if (Intrinsics.areEqual(clsArr[i], Double.TYPE) && !(objArr[i] instanceof Double)) {                    return false;                }                if (Intrinsics.areEqual(clsArr[i], Float.TYPE) && !(objArr[i] instanceof Float)) {                    return false;                }                if (Intrinsics.areEqual(clsArr[i], Long.TYPE) && !(objArr[i] instanceof Long)) {                    return false;                }                if (Intrinsics.areEqual(clsArr[i], Short.TYPE) && !(objArr[i] instanceof Short)) {                    return false;                }            }        }        return true;    }    @NotNull    public final Constructor<?> Ϳ(@NotNull Class<?> cls, @NotNull Class<?>... clsArr) {        int i;        for (Executable executable : Ϳ(cls)) {            if (executable instanceof Constructor) {                Constructor<?> constructor = (Constructor) executable;                Class<?>[] parameterTypes = constructor.getParameterTypes();                if (parameterTypes.length == clsArr.length) {                    int length = clsArr.length;                    while (i < length) {                        i = Intrinsics.areEqual(clsArr[i], parameterTypes[i]) ? i + 1 : 0;                    }                    return constructor;                }                continue;            }        }        throw new NoSuchMethodException("Cannot find matching constructor");    }    @NotNull    public final Method Ϳ(@NotNull Class<?> cls, @NotNull String str, @NotNull Class<?>... clsArr) {        int i;        for (Executable executable : Ϳ(cls)) {            if (Intrinsics.areEqual(executable.getName(), str) && (executable instanceof Method)) {                Method method = (Method) executable;                Class<?>[] parameterTypes = method.getParameterTypes();                if (parameterTypes.length == clsArr.length) {                    int length = clsArr.length;                    while (i < length) {                        i = Intrinsics.areEqual(clsArr[i], parameterTypes[i]) ? i + 1 : 0;                    }                    return method;                }                continue;            }        }        throw new NoSuchMethodException("Cannot find matching method");    }    public final List<Executable> Ϳ(Class<?> cls) {        ArrayList arrayList = new ArrayList();        if (!cls.isPrimitive() && !cls.isArray()) {            synchronized (this) {                try {                    Method declaredMethod = FozaReflectionEnjoyHelper.NeverCall.class.getDeclaredMethod("a", new Class[0]);                    declaredMethod.setAccessible(true);                    MethodHandle unreflect = MethodHandles.lookup().unreflect(declaredMethod);                    Unsafe unsafe = Ԩ;                    long j = unsafe.getLong(cls, ԭ);                    if (j != 0) {                        int i = unsafe.getInt(j);                        for (int i2 = 0; i2 < i; i2++) {                            long j2 = ֈ;                            long j3 = ֏;                            Unsafe unsafe2 = Ԩ;                            unsafe2.putLong(unreflect, ԫ, (i2 * j2) + j + j3);                            unsafe2.putObject(unreflect, Ԭ, (Object) null);                            try {                                MethodHandles.lookup().revealDirect(unreflect);                            } catch (Throwable th) {                            }                            Unsafe unsafe3 = Ԩ;                            Object object = unsafe3.getObject(unreflect, Ԭ);                            Intrinsics.checkNotNull(object, "null cannot be cast to non-null type java.lang.invoke.MethodHandleInfo");                            Object object2 = unsafe3.getObject((MethodHandleInfo) object, ՠ);                            Intrinsics.checkNotNull(object2, "null cannot be cast to non-null type java.lang.reflect.Executable");                            arrayList.add((Executable) object2);                        }                        Unit unit = Unit.INSTANCE;                    }                } catch (IllegalAccessException e) {                } catch (NoSuchMethodException e2) {                }            }        }        return arrayList;    }    @Nullable    public final Object Ϳ(@NotNull Class<?> cls, @Nullable Object obj, @NotNull String str, @NotNull Object... objArr) {        boolean z = true;        if (obj != null && !cls.isInstance(obj)) {            z = false;        }        if (!z) {            throw new IllegalArgumentException("this object is not an instance of the given class".toString());        }        synchronized (this) {            Method declaredMethod = FozaReflectionEnjoyHelper.InvokeStub.class.getDeclaredMethod("invoke", Object[].class);            declaredMethod.setAccessible(true);            Unsafe unsafe = Ԩ;            long j = unsafe.getLong(cls, ԭ);            if (j == 0) {                throw new NoSuchMethodException("Cannot find matching method");            }            int i = unsafe.getInt(j);            for (int i2 = 0; i2 < i; i2++) {                Ԩ.putLong(declaredMethod, ԩ, (i2 * ֈ) + j + ֏);                if (Intrinsics.areEqual(str, declaredMethod.getName()) && Ϳ.Ϳ(declaredMethod.getParameterTypes(), objArr)) {                    return declaredMethod.invoke(obj, objArr);                }            }            Unit unit = Unit.INSTANCE;            throw new NoSuchMethodException("Cannot find matching method");        }    }    @NotNull    public final Object Ϳ(@Nullable Class<?> cls, @NotNull Object... objArr) {        synchronized (this) {            Method declaredMethod = FozaReflectionEnjoyHelper.InvokeStub.class.getDeclaredMethod("invoke", Object[].class);            Constructor declaredConstructor = FozaReflectionEnjoyHelper.InvokeStub.class.getDeclaredConstructor(Object[].class);            declaredConstructor.setAccessible(true);            Unsafe unsafe = Ԩ;            long j = unsafe.getLong(cls, ԭ);            if (j == 0) {                throw new NoSuchMethodException("Cannot find matching constructor");            }            int i = unsafe.getInt(j);            for (int i2 = 0; i2 < i; i2++) {                long j2 = ֏ + (i2 * ֈ) + j;                Unsafe unsafe2 = Ԩ;                unsafe2.putLong(declaredMethod, ԩ, j2);                if (Intrinsics.areEqual("<init>", declaredMethod.getName())) {                    unsafe2.putLong(declaredConstructor, ԩ, j2);                    unsafe2.putObject(declaredConstructor, Ԫ, cls);                    if (Ϳ.Ϳ(declaredConstructor.getParameterTypes(), objArr)) {                        return declaredConstructor.newInstance(Arrays.copyOf(objArr, objArr.length));                    }                }            }            Unit unit = Unit.INSTANCE;            throw new NoSuchMethodException("Cannot find matching constructor");        }    }    public final void Ϳ(Object obj) {        try {            Method declaredMethod = VMRuntime.class.getDeclaredMethod("setHiddenApiExemptions", String[].class);            declaredMethod.setAccessible(true);            ށ = obj;            ހ = declaredMethod;        } catch (Throwable th) {        }    }}